# -*- coding: utf-8 -*-
"""Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1he_0WjA85daZMp1R6zIKnlt7eWMiurig

<a href="https://colab.research.google.com/github/AdarshShah/Mars-Tycho-Brahe-Kepler/blob/main/Assignment1.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Mars Orbit
Author : Adarsh Shah

Date : 18th Aug, 2021
"""

import numpy as np
from matplotlib import pyplot as plt
import pandas as pd
from math import radians, cos, sin, tan, sqrt, fmod, atan, degrees
import datetime
from scipy import optimize as op

"""# Data Preparation"""

# Orbit Center in degrees
c = 120
# Orbit radius
r = 10
# Equant Center
e1 = 1
e2 = 93
# Equant 0 in degrees
z = 57
# Mars angular velocity in degrees per day
s = 360/687
# Data Path
path = "01_data_mars_opposition_updated.csv"

data = pd.read_csv(path)
 
lg = np.array(data['ZodiacIndex']*30 + data['Degree'] + data['Minute']/60 + data['Second']/3600)
elg = [ 0 ]
for i in range(1,12):
  d1 = datetime.datetime(data['Year'][i],data['Month'][i],data['Day'][i],data['Hour'][i],data['Minute.1'][i])
  d2 = datetime.datetime(data['Year'][i-1],data['Month'][i-1],data['Day'][i-1],data['Hour'][i-1],data['Minute.1'][i-1])
  ddelta = d1-d2
  elg += [elg[-1]+ddelta.days+ddelta.seconds/(3600*24)]
elg = np.array(elg)
 
elg.resize((12,1))
lg.resize(12,1)
oppositions=np.append(elg,lg,axis=1)
oppositions
"""# Utils"""

# Equant Polar to co-ordinate
def p2c(e1,e2):
  x = e1*cos(radians(fmod(e2+z,360)))
  y = e1*sin(radians(fmod(e2+z,360)))
  return x,y

# Equant Co-ordinate to Polar
def c2p(x,y):
  e1 = sqrt(x**2+y**2)
  e2 = degrees(atan(y/x))
  return e1,e2

# Intersection of Latitude and orbit.
def intersect(e1,e2,m,c,r):
    f = lambda x : [(x[0]-cos(radians(c)))**2 + (x[1]-sin(radians(c)))**2 - r**2,tan(radians(m))*(e1-x[0])-(e2-x[1])]
    res = op.fsolve(func=f,x0=[e1+2*r*cos(radians(m)),e2+2*r*sin(radians(m))])
    return res

def quad(e1,e2,m,c,r):
  cx = np.cos(np.radians(c))
  cy = np.sin(np.radians(c))

  tn = np.tan(np.radians(m))

  a = (1 + tn ** 2)
  b = -2 * cx + 2 * tn * (e2 - cy - e1 * tn)
  c = (e2 - cy - e1 * tn) ** 2 + cx ** 2 - r ** 2

  discrm = np.sqrt(b ** 2 - 4 * a * c)

  x1 = (-b - discrm) / (2 * a)
  x2 = (-b + discrm) / (2 * a)

  y1 = e2 + (x1 - e1) * tn
  y2 = e2 + (x2 - e1) * tn

  if 0 <= m <= 90 or 270 <= m <= 360:
      X_circle = x1 if x1 >= 0 else x2
      Y_circle = y1 if x1 >= 0 else y2
  else:
      X_circle = x1 if x1 <= 0 else x2
      Y_circle = y1 if x1 <= 0 else y2
  
  return X_circle,Y_circle

# Distance between two co-ordinates.
def distance(x,y):
  return sqrt((y[0]-x[0])**2+(y[1]-x[1])**2)

# Plot
def plot(c,r,e1,e2,z,s,oppositions):
  plt.scatter(cos(radians(c)),sin(radians(c)),c='r')
  plt.scatter(e1,e2,c='b')
  plt.scatter(0,0,c='g')
  
  for o in oppositions[:,0]:
    plt.arrow(0,0,1.5*r*cos(radians(o)),1.5*r*sin(radians(o)),ls='-')
    x,y = quad(0,0,o,c,r)
    plt.scatter(x,y)

  for o in oppositions[:,1]:
    m = fmod(o*s+z,360)
    ex = e1*np.cos(radians(e2+z))
    ey = e1*np.sin(radians(e2+z))
    plt.arrow(ex,ey,1.5*r*cos(radians(m)),1.5*r*sin(radians(m)),ls=':')
    
    x,y = quad(ex,ey,m,c,r)
    plt.scatter(x,y)

  x = np.radians(np.arange(0,360))
  plt.plot(cos(radians(c))+r*np.cos(x),sin(radians(c))+r*np.sin(x))



def obj(X,oppositions):
  c,r,e1,e2,z,s=X
  e,emax = MarsEquantModel(c,r,e1,e2,z,s,oppositions)
  return emax

"""# 1. MarsEquantModel"""

def MarsEquantModel(cf, rf, e1f, e2f, zf, sf, oppositionsf):
    '''
    Parameter Info:
    (cx,cy)= Center of Circle calculated by Polar Coordinate C_dis=1 (distance from Sun) cf(angle from Aris)
    (ex,ey)= Equant position cal by Polar Coordinate e1f (Distance from Sun) e2f (angle from Aris)
    rf= Radius Of Orbit
    sf= Degree per Day
    Dotlinef= Calculation of Strokes angle from Aris and Rotate to Equant 0 by adding Angle Zf
    (X_Circle, Y_Circle)= point Intersection Point of Circle and 12 Strokes in the Direction of the respective Stroke
    Cal_Angle= aTan(Y_Circle/X_Circle) in (-pi,pi] range
    Act_Angle= Given Latitude Angle converted in (-pi,pi] range

    Logic:
    Solving Equation
    (x - cx) ** 2 + (y - cy)**2 =r **2
    (y- ey) = (x-ex) * Tan( Dotlinef )

    simplifying to 2nd Order Equation and solve it
    From (x1,y1), (x2,y2)
    discarding one point by checking Dotline (Stroke angle) lies in which XY quadrant
    ( First And Fourth Quadrant X1 >0 and opposite in Third and Second)

    Return Value:
    Error =Calculated Angle(Cal_Angle)- Actual Longitude Angle (Act_Angle)
    Max Error= Max of absolute Error
    '''
    oppositionsf=np.array(oppositionsf).T # Coverting to 2x12 Array (Daydiff, Actual Longitude)
    C_dis = 1
    cx = C_dis * np.cos(np.radians(cf))
    cy = C_dis * np.sin(np.radians(cf))
    ex = e1f * np.cos(np.radians(e2f +zf))
    ey = e1f * np.sin(np.radians(e2f +zf))
    # Doted Line Angle At Z=0;
    Dotlinef = (oppositionsf[0] * sf + zf) % 360
    # print('Doted line Angle=', Dotlinef)

    X_circle = np.array([np.nan for x in range(0,np.shape(Dotlinef)[0])])
    Y_circle = np.array([np.nan for x in range(0,np.shape(Dotlinef)[0])])

    for k in range(0, np.shape(Dotlinef)[0]): # For Intersect (X,Y) Coordinate
        tanValue = np.tan(np.radians(Dotlinef[k]))
        a = (1 + tanValue ** 2)
        b = -2 * cx + 2 * tanValue * (ey - cy - ex * tanValue)
        c = (ey - cy - ex * tanValue) ** 2 + cx ** 2 - rf ** 2
        delta = np.sqrt(b ** 2 - 4 * a * c)
        x1 = (-b - delta) / (2 * a)
        x2 = (-b + delta) / (2 * a)
        y1 = ey + (x1 - ex) * tanValue
        y2 = ey + (x2 - ex) * tanValue
        if 0 <= Dotlinef[k] <= 90 or 270 <= Dotlinef[k] <= 360:
            X_circle[k] = x1 if x1 >= 0 else x2
            Y_circle[k] = y1 if x1 >= 0 else y2
        else:
            X_circle[k] = x1 if x1 <= 0 else x2
            Y_circle[k] = y1 if x1 <= 0 else y2
        # plt.plot(X_circle[k],Y_circle[k] , 'bo')
    Cal_angle = np.degrees(np.arctan2(Y_circle,X_circle))
    Act_Angle1 = np.array([i if i <= 180  else i-360 for i in oppositionsf[1]])
    print(Cal_angle,Act_Angle1)
    # print('Dotline',Dotlinef,'\nX_circle',X_circle,'\n Y_circle',Y_circle,'\nCal_angle=',Cal_angle,'\n Act_Angle',Act_Angle1)
    # errors = np.array([min(np.absolute(np.subtract(Act_Angle1,Cal_angle[i]))) for i in range(12)])
    errors = np.subtract(Cal_angle,Act_Angle1)
    return errors, np.max(np.absolute(errors))

c = 120
e1 = 1
e2 = 93
z = 57
r = 10
s = 360 / 687

# Q1 Test Case
print('Q1 Error(deg.) & absolute Max error (deg.) Test Case Result')
print(MarsEquantModel(c, r, e1, e2, z, s, oppositions))
#
#def MarsEquantModel(c,r,e1,e2,z,s,oppositions):
#  # Intersection of Heliolongitudes and orbit
#  #Intersection of Equantlongitudes and orbit
#  el = list()
#
#  for o in oppositions[:,1]:
#    ex = e1*np.cos(np.radians(e2+z))
#    ey = e1*np.sin(np.radians(e2+z))
#    x,y = quad(ex,ey,(o*s+z)%360,c,r)
#    el.append([x,y])
#  x = np.radians(np.arange(0,360))
#  d1 = list()
#  d2 = list()
#  d3 = list()
#
#  for x in el:
#    d1.append(np.degrees(np.arctan2(x[1],x[0])))
#  
#  d3 = [i if i<=180 else i-360 for i in oppositions[:,0]]
#  d2 = [a-b for a,b in zip(d1,d3)]
#  print(d1,d3)
#  # Errors
#  errors = np.array(d2)
#  max_error = np.max(np.abs(errors))
#  return errors,max_error
#
#MarsEquantModel(c,r,e1,e2,z,s,oppositions)
#
#"""#2. BestOrbitInnerParams
#
#
#
#
#"""
#
#def bestOrbitInnerParams(r,s,oppositions):
#  cf = 10
#  e1f = 1
#  e2f = 10
#  print("Computing: [",end='')
#  def obj(X0,oppositions):
#    c,e1,e2,z = X0
#    e,emax = MarsEquantModel(c,r,e1,e2,z,s,oppositions)
#    return emax
#  for i in range(3):
#    print("*",end='')
#    z = np.linspace(0,360,360)
#    z_error = np.array([obj((cf,e1f,e2f,i),oppositions) for i in z])
#    zf = z[z_error.argmin()]
#    
#    e2 = np.linspace(zf,360,360)
#    e2_error = np.array([obj((cf,e1f,i,zf),oppositions) for i in e2])
#    e2f = e2[e2_error.argmin()]
#    
#    c = np.linspace(0,360,360)
#    c_error = np.array([obj((i,e1f,e2f,zf),oppositions) for i in c])
#    cf = c[c_error.argmin()]
#    
#    e1 = np.linspace(0,0.5*r,300)
#    e1_error = np.array([obj((cf,i,e2f,zf),oppositions) for i in e1])
#    e1f = e1[e1_error.argmin()]
#    
#  print("]")
#  res = op.minimize(fun=obj,x0=[cf,e1f,e2f,zf],args=oppositions,method='Nelder-Mead', options={'xatol' : 1e-5 ,'disp':False, 'return_all' :False})
#  errors,maxError = MarsEquantModel(cf,r,e1f,e2f,zf,s,oppositions)
#  return cf,e1f,e2f,zf,errors,maxError
#
#bestOrbitInnerParams(10,360/687,oppositions)
#
#"""#3. BestS"""
#
#def bestS(r,oppositions):
#  maxError = 720
#  sgood = 360/687
#  print("BestS :")
#  iter=1
#  for s in np.linspace(360/(687+0.1),360/(687-0.1),12):
#    print(f'{iter:2}: ',end='')
#    iter+=1
#    _c,_e1,_e2,_z,_errors,_maxError = bestOrbitInnerParams(r,s,oppositions)
#    if maxError > _maxError:
#      c,e1,e2,z,errors,maxError=_c,_e1,_e2,_z,_errors,_maxError
#      sgood = s
#  print("]")
#  #optimizing in the neighbourhood of c,e1,e2,z,s
#  '''res = op.minimize(fun=obj,x0=[c,r,e1,e2,z,sgood],args=oppositions,method='Nelder-Mead', options={'xatol' : 1e-5 ,'disp':False, 'return_all' :False})
#  c,r,e1,e2,z,s = res.x
#  errors,maxError = MarsEquantModel(c,r,e1,e2,z,s,oppositions)'''
#  c,e1,e2,z,errors,maxError = bestOrbitInnerParams(r,sgood,oppositions)
#  return sgood,errors,maxError
#
#bestS(10,oppositions)
#
#"""#4. BestR"""
#
#def bestR(s,oppositions):
#  maxError = 720
#  rgood = 9
#  print("BestR :")
#  iter=1
#  def obj(X0,opposition):
#    c,r,e1,e2,z = X0
#
#  for r in np.linspace(8,9,10):
#    print(f'{iter:2}: ',end='')
#    iter+=1
#    _c,_e1,_e2,_z,_errors,_maxError = bestOrbitInnerParams(r,s,oppositions)
#    if maxError > _maxError:
#      c,e1,e2,z,errors,maxError=_c,_e1,_e2,_z,_errors,_maxError
#      rgood = r
#  print("]")
#  #optimizing in the neighbourhood of c,r,e1,e2,z
#  #res = op.minimize(fun=obj,x0=[c,rgood,e1,e2,z,s],args=oppositions,method='Nelder-Mead', options={'xatol' : 1e-5 ,'disp':False, 'return_all' :False})
#  c,e1,e2,error,maxError = bestOrbitInnerParams(rgood,s,oppositions)
#  return rgood,errors,maxError
#
#def bestR(s,oppositions):
#  maxError = 720
#  iter = 1
#  best_rf = 5
#  for o_rf in np.linspace(5,10,10):
#    _c,_e1,_e2,_z,_errors,_maxError = bestOrbitInnerParams(o_rf,s,oppositions)
#    if maxError>_maxError:
#      c,e1,e2,z,errors,maxError = _c,_e1,_e2,_z,_errors,_maxError
#      best_rf = o_rf
#    cx = np.cos(np.radians(_c))
#    cy = np.sin(np.radians(_c))
#    ex = _e1 * np.cos(np.radians(_e2))
#    ey = _e1 * np.sin(np.radians(_e2))
#    Dotlinef = (oppositions.T[1] * s + _z) % 360
#    # print('Doted line Angle=', Dotlinef)
#    X_Line = (ey-ex*np.tan(np.radians(Dotlinef))) / (np.tan(np.radians(oppositions.T[0]))-np.tan(np.radians(Dotlinef)))
#    Y_Line = X_Line * np.tan(np.radians(oppositions.T[0]))
#    dis_C = np.sqrt((X_Line - cx) ** 2 + (Y_Line - cy) ** 2)
#    New_rf = np.mean(dis_C)
#    print(New_rf)
#    for rf in np.linspace(New_rf,min(10,New_rf+0.5),5):
#      _c,_e1,_e2,_z,_errors,_maxError = bestOrbitInnerParams(rf,s,oppositions)
#      if maxError>_maxError:
#        best_rf = rf
#        print("Change "+str(best_rf))
#  c,e1,e2,z,errors,maxError = bestOrbitInnerParams(best_rf,s,oppositions)
#  return best_rf,errors,maxError
#
#bestR(s,oppositions)
#
#"""#5. BestMarsOrbitParams"""
#
#def bestMarsOrbitParams(oppositions):
#  r = 5
#  s = 360/687
#  emaxt = 1
#  while(emaxt>4/60):
#    s,er,emax = bestS(r,oppositions)
#    r,er,emax = bestR(s,oppositions)
#
#    c,e1,e2,z,errors,emax = bestOrbitInnerParams(r,s,oppositions)
#    res = op.minimize(fun=obj,x0=[c,r,e1,e2,z,s],args=oppositions,method='Nelder-Mead', options={'xatol' : 1e-5 ,'disp':False, 'return_all' :False})
#    c,r,e1,e2,z,s = res.x
#    if(emaxt-emax)<0.01:
#      break
#    emaxt = emax
#    print(c,r,e1,e2,z,s,emax)
#  plot(c,r,e1,e2,z,s,oppositions)
#  plt.xlim(-(r + 3), r + 3)
#  plt.ylim(-(r + 3), r + 3)
#  plt.grid()
#  plt.show()
#  print([e1,e2])
#  e1,e2 = c2p(e1,e2)
#  return r,s,c,e1,e2,z,er,emax
#
#bestMarsOrbitParams(oppositions)
#
#ex = 1.6029181600675653*cos(91.94272990410497+55.48468260460285)
#ey = 1.6029181600675653*sin(91.94272990410497+55.48468260460285)
#plot(164.15863597917422, 6.904500648440575, 1.303956739914443, 148.12807041559088, 89.49564395237483,55.478262438595706,oppositions)
#plt.xlim(-(6.904500648440575 + 3), 6.904500648440575 + 3)
#plt.ylim(-(6.904500648440575 + 3), 6.904500648440575 + 3)
#plt.grid()
#plt.show()
#
#PlotOut(oppositions,55.48468260460285,172.9987003991455,8.64818816391562,1.6029181600675653,91.94272990410497,0.5240933473326761)
#plt.xlim(-(8.64818816391562 + 3), 8.64818816391562 + 3)
#plt.ylim(-(8.64818816391562 + 3), 8.64818816391562 + 3)
#plt.grid()
#plt.show()
#
#oppositions.T[1]
#
